# コードレビュー判断体系 — 技術判断ルールセット

> **Author:** Takahiro（12年のフルスタックエンジニア経験に基づく）
> **Purpose:** 人間のレビュアー・チームメンバー・AIレビューエージェントが共通の判断基準でコードレビューを実施するための統一ルールセット
> **Version:** 1.0.0

---

## 最上位原則

**「ユーザーの意図を完遂させる」**

すべてのレビュー判断はこの原則に帰結する。7つの視点は独立した項目ではなく、この原則を実現するための手段である。判断が衝突した場合は「どちらがよりユーザーの意図の完遂に貢献するか」で優先度を決定する。

---

## 判断体系の全体構造

```
[最上位原則] ユーザーの意図を完遂させる
│
├─ [データ層] ── 変更耐性の土台
│   ├─ 正規化
│   ├─ キー設計
│   └─ マスタ設計
│
├─ [インターフェース層] ── システムの柔軟性の要
│   ├─ API責務の分離（癒着排除）
│   ├─ I/Fファースト設計
│   └─ データフロー全体の整合性
│
├─ [コード層] ── 実装品質
│   ├─ 冗長性排除
│   ├─ 変更耐性（分岐の将来性判断）
│   ├─ 可読性
│   └─ エラーハンドリング
│
├─ [非機能層] ── システムの信頼性
│   ├─ パフォーマンス
│   ├─ セキュリティ
│   └─ リソースコスト
│
└─ [横断原則]
    ├─ 汎用化はユーザー価値に貢献する場合のみ
    ├─ 用途のない抽象化は入れない
    └─ 他者が読んで意図がわかるか（配慮の有無）
```

レビューは上位の層から順に確認する。データ層に問題があればコード層の議論は後回しにする。土台が腐っていれば上に何を積んでも意味がない。

---

## 1. データ層：変更耐性の土台

データ構造はシステム全体に波及するため、最も慎重にレビューする。

### 1.1 正規化

```
[データは正規化されているか？]
├─ YES → OK
└─ NO → 非正規化の根拠があるか？
    ├─ read/writeコストバランスの明確な理由がある → 許容（根拠を記録）
    └─ 根拠がない → 正規化を指示
```

**判断基準：**

- 基本方針はデータを正規化してきれいに揃えること
- 非正規化は例外措置であり、要件・仕様に基づくread/writeコストバランスの根拠が必要
- 「パフォーマンスのため」という漠然とした理由は不可。具体的な計測値や想定アクセスパターンを求める

### 1.2 キー設計

```
[主キーの設計は適切か？]
├─ 意味を持たないユニークID（UUID等）がPKになっているか？
│   ├─ YES → そのIDがrelationに使用されているか確認
│   └─ NO → 業務的な意味を持つキーがPKになっている
│       → 変更リスクを指摘。アジャイル開発ではPKの変更は致命的
│
├─ 複合キーで強い制約を作っていないか？
│   ├─ 複合キーがある → 変更耐性リスクを警告
│   │   → UPSERT等の利便性があっても、アジャイル開発中は変更に弱い
│   └─ ない → OK
```

**判断基準：**

- アジャイルで開発を進める前提では、テーブルごとに意味を持たないユニークIDをPKとし、relationにはそのIDを使用する
- 複合キーによる強い制約はDB変更に弱い。物事が確定するまでは避ける
- 最近のDBはjoinが高速であるため、正規化＋ID参照のコストは許容範囲

### 1.3 マスタ設計

```
[マスタデータの設計は適切か？]
├─ selectやautocomplete等のUI要素に使うデータか？
│   → マスタ化されているか確認
├─ 静的マスタか動的マスタか判断されているか？
│   ├─ 静的（コード値等） → 変更頻度が極めて低いことが確認されているか
│   └─ 動的（ユーザーが追加・編集可能） → CRUD機能の設計があるか
```

---

## 2. インターフェース層：システムの柔軟性の要

I/F設計はデータとUIの接合面であり、システム全体の柔軟性を決定する。

### 2.1 API責務の分離（癒着排除）

```
[APIに癒着がないか？]
│
├─ パターンA：責務の混同
│   └─ 一覧取得と詳細取得が分離されていないケース
│       → クライアント側にグループ化・集約の責務を押し付けていないか？
│       → 分離すべき。1つのAPIは1つの責務
│
├─ パターンB：レスポンスの肥大化
│   └─ 1つのエンドポイントに関連データを全部載せているケース
│       例：ユーザー取得APIに所属チーム一覧が配列で全部入っている
│       → レスポンスが重くなる
│       → 別リソースとして切り出す（ユーザーID → 所属チーム一覧取得API）
```

**判断基準：**

- 1つのAPIが1つの責務を超えていないか
- クライアントに集約・加工の責務を押し付けていないか
- レスポンスに別リソースとして切るべきデータが混在していないか
- API定義を見たとき、使い方が直感的にわかる単位で切られているか

### 2.2 I/Fファースト設計

I/Fは最初に設計し、ダミーデータで全データフローを検証する。I/F設計時には以下の6視点を同時に確認する：

| # | 視点 | 確認内容 |
|---|------|---------|
| 1 | 技術スタック制約 | RDB／ドキュメントDB／物理ファイルのどれが適切か |
| 2 | ユースケース | 壁打ちログからのユーザー利用シーンの想定 |
| 3 | ユーザビリティ | UIの最適な入出力表現に適合するデータ形式か |
| 4 | データ設計上の都合 | マスタの静的/動的、select/autocomplete等のUI要素との連動 |
| 5 | 型の継承関係 | class/interface/typeの継承・実装関係に矛盾がないか |
| 6 | データフロー整合性 | 起点のI/Fから派生する全I/Fが一気通貫で矛盾しないか |

**判断基準：**

- 1か所のI/Fを見たとき、データフロー上つながりのあるすべてのI/Fとの整合性が取れているか
- I/Fにデータの癒着が見られないか
- 役割の混同がないか
- APIパスの構成とI/Fが対応しており、第三者が見て使い方がわかるか

### 2.3 データフロー全体の整合性

```
[I/F間のデータフローに矛盾がないか？]
├─ 起点のI/Fから終点まで、データの型・構造が一貫しているか
├─ 途中で不要な変換・マッピングが発生していないか
└─ フロー上の各I/Fが6視点（上記）を満たしているか
```

---

## 3. コード層：実装品質

### 3.1 冗長性排除

```
[似た処理が複数箇所にある]
├─ 引数追加で統合可能か？
│   ├─ YES → 統合後の関数が長くなりすぎないか？
│   │   ├─ YES → 共通部分だけ基礎関数に切り出し、各処理はラッパーで分離
│   │   └─ NO → 統合した関数の責務は単一か？
│   │       ├─ YES → 統合する
│   │       └─ NO → 責務ごとに分けて、共通部分だけ基礎関数に抽出
│   └─ NO → 処理の意味的な類似度は高いか？
│       ├─ YES → 抽象化の設計を見直す（インターフェース、ストラテジー等）
│       └─ NO → 別関数のまま維持（重複に見えるが責務が異なる）
```

**判断基準：**

- 冗長の判定は行数ではなく、責務の重複で判断する
- 統合はメンテナンス性の向上が目的。統合によって関数が肥大化するなら基礎関数＋ラッパーに分離する
- あえて分けた方が「その関数が何の役割なのか」がわかりやすいケースもある。意味的な境界を尊重する

### 3.2 変更耐性（分岐の将来性判断）

```
[分岐処理がある場合]
├─ 分岐の種類は増える可能性があるか？
│   ├─ 確認済み・増えない → 最短・高パフォーマンスな分岐でOK
│   │   → 処理内容が代入なら短縮記述（三項演算子等）も許容
│   ├─ 未確認 → 即確認させる。確認なく実装を進めるのは不可
│   └─ 増える or 種類未確定
│       → 固定値（'first'等の文字列リテラル）は避ける
│       → enum等の定義で動かせる設計にする
│
[汎用化の判断]
├─ 汎用化した先に開発効率性・システム拡張性・可用性への貢献があるか？
│   ├─ YES → パフォーマンスへの軽微な影響は許容して積極的に汎用化
│   └─ NO → 用途のない汎用性は入れない。可読性が落ちる
```

**判断基準：**

- 汎用性は目的ではなく手段。ユーザーへの提供価値に貢献する場合のみ採用する
- 「できない」と言わずに済む、短時間で実現できる——この状態を作れる設計が良い設計

### 3.3 可読性

```
[可読性判断]
│
├─ 定義の明確さ
│   ├─ マジックナンバーが使われていないか？
│   │   → intの引数で1, 2等の固定値で分岐 → NG
│   │   → enumで列挙型の定義を持ち、enum定義の数値をコードとして使う
│   ├─ 型定義（type/interface/enum）が適切に整備されているか？
│   └─ サマリー・コメントが最低限あるか？
│       → 引数に何を渡すとどう解釈されるか、第三者がわかるか
│
├─ 構造の意図
│   ├─ フォルダ構成に設計意図があるか？
│   │   → レイヤーが意識されているか（DDD/ヘキサゴナル等の設計思想）
│   │   → helpers/utils/extensionsが意味なく乱立していないか
│   │   → 「なぜここに置いたのか」が構造から読み取れるか
│   └─ クラスの分割単位に責務の境界があるか？
│
└─ 粒度の適切さ
    ├─ 1メソッドが異常に長くないか？
    │   → 長い場合、整理せず継ぎ足した結果ではないか
    │   → 責務ごとに分割すべき
    ├─ 1クラスが肥大化していないか？
    └─ ネスト・ジャンプが深くなっていないか？
```

**判断基準：**

- 可読性の本質は「他者への配慮の有無」
- 自分しかわからないコードは配慮の欠如として指摘する
- フォルダ構成は設計思想の表出。意図のない構成は読み進める気が失せる
- 1メソッド・1クラスの肥大化は設計不足のサイン

### 3.4 エラーハンドリング

```
[ユーザーが意図した操作を完遂できたか？]
├─ YES → 正常終了
└─ NO → なぜ？
    │
    ├─ 必要条件を満たしていない
    │   ├─ 理由をユーザーに明示する
    │   ├─ ユーザーのアクションで解決可能 → アクションを誘導する
    │   └─ ユーザーでは解決不可能 → 下記へ
    │
    ├─ システムエラー
    │   ├─ エラー概要をユーザーに簡潔に通知（技術的詳細は不要）
    │   ├─ システムで自動復旧可能か？
    │   │   ├─ YES → 自動復旧し、結果をユーザーに通知
    │   │   └─ NO → 人的サポートへ誘導
    │   └─ 人的サポートが必要な場合の導線が設計されているか
    │
    └─ [共通] ログ設計
        ├─ クリティカルエラー → 無条件で取得
        ├─ ワーニング・軽微なエラー → 必要時に取得できる設計になっているか
        └─ ログの粒度を切替可能な設計になっているか
```

**判断基準：**

- エラーで落ちて止まるのは論外
- 想定できるエラーはすべてキャッチし、ユーザーに何が起きたか知らせるか、ログに記録する
- MVP以降、少なくともリリース前までに「ユーザーの意図が完遂できなかったケース」の対応が開発・運用サポートの視点で議論・解決されていること
- レビューに来る前にエラーハンドリングの設計を考えて対応済みであることを前提とする

---

## 4. 非機能層：システムの信頼性

### 4.1 パフォーマンス

**最終判断基準はUI体感に持つ。** ユーザーの体感はUIでしか起こらないため、API単体の速度は意識するが、アプリケーション全体としての判断はUIで行う。

| 項目 | 基準値 | 超過時の対応 |
|------|--------|-------------|
| ユーザーから見て画面に変化がない時間 | 100ms以下を目指す | — |
| 初期表示 | 200ms以下 | 非同期ロード＋スケルトン等で体感補償 |
| 検索結果の表示 | 100ms以下 | キューで管理し、完了時にプッシュ通知的に表示 |
| 上記を超える処理 | — | 非同期処理＋完了通知の仕組みを導入 |

**判断基準：**

- ユーザーにストレスを与えるシステムであってはならない
- 遅延があってもユーザーに「止まった」と思わせない手法（プログレス表示、スケルトン、非同期＋通知等）を用いればよい
- すべての処理が数値基準を満たす必要はないが、体感上の停止感は排除する

### 4.2 セキュリティ

```
[セキュリティ判断 — データの機密度で深度を決定]
│
├─ 最優先：個人情報・決済情報 → 最深度レビュー
├─ 次点：社内データ → 同等の視点で深くレビュー
└─ その他 → 標準レビュー
│
├─ データ保管
│   ├─ 保管先DBはどの環境から参照可能か？
│   ├─ データ構造上、秘匿データが適切に分離されているか？
│   └─ 暗号化されているか？
│
├─ アクセス経路
│   ├─ そのデータにアクセスする手順は制御されているか？
│   ├─ どのシステムが参照しているか把握されているか？
│   └─ API保護
│       ├─ トークン認証等で保護されているか？
│       ├─ 危険なコントローラが外部に露出していないか？
│       ├─ 多層API構成でプライベートネットワーク内に配置すべきか？
│       └─ インバウンド制御は適切か？
│
└─ フロントエンド固有
    ├─ キー・クレデンシャル情報がコードや静的ファイルに露出していないか？
    ├─ 秘匿情報がDOMやネットワークタブから見えていないか？
    └─ 容易にスクレイピングされる状態になっていないか？
```

### 4.3 リソースコスト

```
[リソースコスト判断]
│
├─ 環境全体の設計
│   ├─ 同居するアプリケーションは何か？
│   ├─ 各アプリのCPU・メモリ占有率の上限設定は適切か？
│   │   （IIS → AppPool / Linux → コンテナごとに設定）
│   └─ 全アプリの最重処理が同時発生した場合の想定はあるか？
│
├─ キャパシティプランニング
│   ├─ 同時接続ユーザー数の最大想定は？ → 実運用上妥当か？
│   ├─ その想定を加味してインフラのサイジングが決定されているか？
│   └─ 瞬間的な負荷増に対する拡張まで検討されているか？
│       （例：EC2のCPUクレジット管理、オートスケーリング）
│
├─ 定時タスク・バッチ
│   └─ 実行時間帯の負荷を考慮して設計されているか？
│
├─ ファイル・ストレージ
│   ├─ 動作環境内にファイル出力があるか？
│   ├─ 永久に増え続けるロジックになっていないか？
│   └─ ローテートが有効になっているか？
│
└─ 致命的パターンの検出（以下は絶対に見逃さない）
    ├─ メモリリークの危険があるライブラリ・コンテナイメージの使用
    ├─ 無限ループの発生可能性
    └─ デッドロックの発生可能性
```

---

## 5. 横断原則

以下の原則はすべての層・すべてのレビュー視点に横断的に適用される。

### 5.1 汎用化の判断

- 汎用化はユーザー価値に貢献する場合のみ行う
- 開発効率性・システム拡張性・可用性に多大な貢献があるなら、パフォーマンスの軽微な低下を許容して積極的に採用
- 用途のない無駄な汎用性は可読性を落とす。入れない

### 5.2 配慮の原則

- コードは自分のためだけに書くものではない
- 他者が読んで意図がわかるか、を常に問う
- マジックナンバー、意味のない変数名、意図不明なフォルダ構成は「配慮の欠如」として指摘する

### 5.3 レビュー前の前提

- エラーハンドリングの設計はレビューに来る前に考えて対応済みであること
- 分岐の将来性（種類が増えるかどうか）はレビュー前に確認済みであること
- 「とりあえず動く」状態でレビューに出さない

---

## 付録：AIレビューエージェント向け運用ガイド

本ルールセットをAIレビューエージェント（Claude Code等）に組み込む際の指針。

### コンテキスト設定

レビュー実行前に以下の情報をAIに提供すること：

1. **プロジェクトの技術スタック**（言語、フレームワーク、DB種別、インフラ構成）
2. **扱うデータの機密度**（個人情報・決済情報の有無）
3. **動作環境の制約**（同居するシステム、リソース上限）
4. **現在のフェーズ**（プロトタイプ／MVP／リリース前／運用中）
5. **パフォーマンス基準**（デフォルトは本ドキュメントの基準値を適用）

### レビュー実行順序

1. データ層 → 2. インターフェース層 → 3. コード層 → 4. 非機能層 の順に実施
上位層に問題がある場合、下位層のレビューは保留し、上位層の修正を優先指示する

### 判定の出力形式

各指摘には以下を含めること：

- **視点：** どの視点での指摘か（冗長性、変更耐性、セキュリティ等）
- **重大度：** CRITICAL（即修正）/ WARNING（修正推奨）/ INFO（改善提案）
- **理由：** なぜ問題なのか（最上位原則との関連を明記）
- **対応案：** 具体的な修正方針

### 判断の衝突が起きた場合

複数の視点で判断が矛盾する場合は、最上位原則「ユーザーの意図を完遂させる」に立ち返り、よりユーザー価値に貢献する方を選択する。判断の根拠を明記すること。
