# 第4章：Phase 3〜5 ── 設計とプロトタイプの反復ループ

## フェーズの性格が変わる

Phase 0〜2は「何を作るか」を見極めるフェーズだった。Phase 3以降は「どう作るか」を決めるフェーズだ。

ここから壁打ちの姿勢が変わる。

Phase 0〜2ではAIは「引き出す」側だった。オペレーターのドメイン知識を問いで引き出す。Phase 3以降ではAIは「提案する」側に回る。技術的な選択肢を積極的に比較・提示し、トレードオフを明確にする。

ただし、最終判断はオペレーターが下す。「どの技術をどこに使うか」「データをどう持つか」は、ドメイン知識が判断を左右するからだ。業界特性、既存システムとの整合、実業務の癖。これらはAIには見えない。

## Phase 3：要件定義

### 形式よりも中身

Phase 3の要件定義で重要なのは、形式的なドキュメントを作ることではない。

従来の受託開発では、分厚い要件定義書を納品物として作成することがあった。だが、AIネイティブ開発では、AIとの壁打ちのログそのものが要件定義の実体だ。重要なのは「決まっていること」と「決まっていないこと」が明確に区別できる状態であることだ。

### 整理すべき項目

**業務要件：**
- 機能一覧（Phase 2のユースケースから導出する。漏れなく導出できているかの検証が重要）
- 各機能の入出力定義
- 業務ルール・制約条件
- ユーザー権限の定義

**非機能要件：**
- パフォーマンス基準（デフォルト：初期表示200ms以下、検索100ms以下）
- セキュリティ要件（扱うデータの機密度に応じた対策レベル）
- 同時接続ユーザー数の想定
- 動作環境の制約
- 可用性要件

### データ機密度の特定

見落とされがちだが極めて重要なのが、扱うデータの機密度の特定だ。

- 個人情報を扱うか
- 決済情報を扱うか
- 医療情報、金融情報など業界固有の機密データはあるか

これによってセキュリティ要件のレベルが変わり、Phase 4の技術スタック選定にも直接影響する。後から「実は個人情報を扱っていた」と判明すると、アーキテクチャレベルの手戻りが発生する。

## Phase 4：技術スタック確定

### AIが提案し、オペレーターが判断する

Phase 4は、AIの技術的知見とオペレーターのドメイン知識が最も明確に交差するフェーズだ。

AIは各技術の特性、パフォーマンス特性、エコシステムの成熟度、学習コストなどを比較・提示する。オペレーターは、それを自分の業務文脈に照らして判断する。

例えば、AIが「この要件ならPostgreSQLよりMongoDBの方が適している」と提案したとする。技術的には正しいかもしれない。だが、オペレーターが「顧客の既存システムがすべてOracle上で動いており、DBAがRDB以外の運用経験がない」という文脈を持っているなら、その提案は採用できない。

これが「適用判断はオペレーターに委ねる」の具体的な意味だ。

### 検討項目

- フロントエンド（フレームワーク、UIライブラリ）
- バックエンド（言語、フレームワーク、API設計方針）
- データベース（RDB / ドキュメントDB / ファイル保管）
- インフラ（クラウド / オンプレミス、デプロイ構成）
- 認証・認可の方式
- CI/CD構成

各選定に対して「なぜそれを選んだのか」を要件ベースで説明できることが完了条件だ。「流行っているから」「前に使ったことがあるから」は理由にならない。

## Phase 5：基本設計＋プロトタイプ開発

### Phase 5だけが持つ構造的特性

Phase 0〜4は「壁打ち → 完了条件判定 → 次へ」の線形進行だ。Phase 5は違う。**内部に反復ループを持つ**。

```
I/F設計 ──→ プロトタイプで検証 ──→ 矛盾・不整合を検出 ──→ I/F設計を修正 ──→ 再検証
   ↑                                                                          │
   └──────────────────────────────────────────────────────────────────────────┘
```

設計とプロトタイプは分離された工程ではない。相互に検証し合う並行プロセスだ。

なぜこの構造なのか。設計だけで完璧なI/Fを定義するのは不可能だからだ。紙の上では整合しているように見えても、実際にデータを流してみると矛盾が見つかる。だからプロトタイプで実証し、矛盾をI/F設計にフィードバックし、修正して再検証する。

この反復ループの終了条件は明確だ。**全データフローがI/Fレベルで矛盾なく通ること**。

### I/F設計の6視点

I/Fを設計する際、以下の6視点を同時に確認する。

1. **技術スタック制約：** Phase 4で確定したDB種別・ファイル形式との整合性
2. **ユースケース：** Phase 2の壁打ちログからのユーザー利用シーン想定
3. **ユーザビリティ：** UIの最適な入出力表現に適合するデータ形式か
4. **データ設計上の都合：** マスタの静的/動的判断、select/autocomplete等のUI要素との連動
5. **型の継承関係：** class/interface/typeの継承・実装関係に矛盾がないか
6. **データフロー整合性：** 起点I/Fから派生する全I/Fが一気通貫で整合しているか

1か所のI/Fに着目したら、データフロー上つながりのある全I/Fを一気通貫で矛盾なく設計すること。部分最適ではなく全体最適を求める。

### データ設計の原則

- **データは正規化する。** 非正規化は例外措置であり、read/writeコストバランスの明確な根拠が必要
- **テーブルごとに意味を持たないユニークIDをPKとする。** relationにはそのIDを使用する
- **複合キーで強い制約を作らない。** アジャイル開発中は変更に弱い
- **マスタデータは静的/動的を判断する。** 動的マスタにはCRUD機能を設計する

### API設計の原則

- **1つのAPIは1つの責務。** 癒着させない
- **クライアント側に集約・加工の責務を押し付けない**
- **レスポンスに別リソースとして切るべきデータを混在させない**
- **API定義を見て使い方がわかる単位で切る**

API設計でよくある癒着パターンは2つだ。

**パターンA：責務の混同。** 1つのAPIが「一覧取得」と「集計」を同時にやっている。分離すべきだ。

**パターンB：レスポンスの肥大化。** ユーザー情報を返すAPIに、そのユーザーの注文履歴も所属部署も全部含めている。ユーザー情報、注文履歴、所属部署はそれぞれ別のAPIとして切るべきだ。

### プロトタイプの位置づけ

プロトタイプは「デモ用のモックアップ」ではない。**設計の検証手段**だ。

- ダミーデータを用いて全データフローを通す
- UIの操作感ではなく、データの流れの整合性を検証する
- 矛盾が見つかったらI/F設計に戻って修正する
- コーディングエージェントを活用して高速にプロトタイプを作成する

プロトタイプはUI上で動作確認できるレベルまで作る。「画面遷移はできるが、データが表示されない」では検証にならない。

### 差し戻しの判断

Phase 5でI/F設計やデータフローに重大な矛盾が見つかった場合、Phase 5内のループで解決できるとは限らない。

矛盾の原因がユースケースの不足にあるなら、Phase 2に差し戻す。要件の漏れが原因なら、Phase 3に差し戻す。

差し戻しを「手戻り」とネガティブに捉えるべきではない。プロトタイプで矛盾を発見できたこと自体が、この手法の設計が正しく機能している証拠だ。本実装に入ってから発見するよりも、はるかにコストが低い。
