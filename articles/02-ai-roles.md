# 第2章：5つのAIロールと相互牽制の設計原則

## AIを「1つのツール」として使ってはいけない理由

多くの開発者はAIを1つの万能ツールとして使っている。同じAIに設計を相談し、コードを書かせ、そのコードのレビューを頼み、テストまで書かせる。

これは、同一人物に設計・実装・レビュー・テストをすべて任せているのと構造的に同じ問題を抱えている。

人間の開発チームで「自分が書いたコードを自分でレビューする」ことを許容する組織はほとんどない。なぜなら、自分の出力に対する批判的検証は構造的に弱くなるからだ。自分では気づかない前提、自分では見えない盲点が必ず存在する。

AIでもこれは同じだ。実装したAIにレビューを頼めば、自身の出力を肯定する方向にバイアスがかかる。これは技術的な限界ではなく、構造的な問題だ。

## 5つのAIロール

本手法では、AIを以下の5つの独立した役割に分離する。

### 1. PM・スクラムマスター
**責務：** GitHub連携の進捗管理、要件との整合性確認、フィードバック共有

進捗を前に進める責任を持つ。要件からの逸脱を検知し、コーディングエージェントに軌道修正を促す。フル稼働はPhase 7〜8。

### 2. コーディングエージェント
**責務：** 実装の主体

設計に基づいてコードを書く。Phase 5以降で稼働する。オペレーターはこのAIの出力を直接レビューするのではなく、コードレビュアーとシステム監査官のレビュー結果を通じて判断する。

### 3. コードレビュアー
**責務：** 7つのレビュー視点に基づくコード品質レビュー（品質ゲート）

コーディングエージェントの出力を、冗長性排除・変更耐性・エラーハンドリング・パフォーマンス・リソースコスト・セキュリティ・可読性の7視点で評価する。フル稼働はPhase 7〜8。

### 4. システム監査官
**責務：** 安全性・安定性・可用性に特化した独立監査（安全ゲート）

コードレビュアーとは異なる観点で検証する。「きれいか・保守しやすいか」ではなく「安全か・壊れないか」を問う。セキュリティとリソースコストに関する指摘は全ロールに対して最優先で適用される。フル稼働はPhase 7〜8。

### 5. ユーザー・運用サポート
**責務：** ペルソナベースのテストシナリオ策定・UX検証

PMが定義した要件・優先度を、エンドユーザー視点で検証する。Phase 6以降で稼働する。

## なぜPM/スクラムマスターとコードレビュアーを分離するのか

この分離は本手法で最も議論を呼ぶ設計判断の1つかもしれない。「PMがレビューも見ればいいのでは？」という声が聞こえてきそうだ。

答えは明確だ。**利益相反が発生するからだ。**

PM・スクラムマスターには「進捗を前に進める」責務がある。コードレビュアーには「品質基準に達するまで止める」責務がある。この2つは本質的に相反する。

同一ロールに同居させると何が起きるか。進捗が遅れているとき、レビューの基準が緩くなる。「ここは後で直そう」「この程度なら大丈夫」── 進捗圧力がレビューを形骸化させる。

これは人間のチームでも頻繁に起きる問題だ。PMがレビュアーを兼ねるチームで「リリース日が迫っているから、このレビュー指摘は次のスプリントで対応しよう」という判断が横行するのを見たことがある人は多いだろう。

AIであっても、同一のコンテキストで「進捗を進める」と「品質で止める」を両立させるのは困難だ。だから分離する。

## なぜコードレビュアーとシステム監査官を分離するのか

両者は同じコードを検証するが、レンズが違う。

- **コードレビュアー：** 「きれいか・保守しやすいか」を問う
- **システム監査官：** 「安全か・壊れないか」を問う

兼任させると、どちらかのレンズが支配的になる。コードの可読性を重視するレビュアーが安全性の検証を兼ねると、可読性の高いコードに対してセキュリティの指摘が甘くなる。逆に、セキュリティに厳格な監査官がコード品質のレビューを兼ねると、セキュリティさえ通ればコードの保守性は二の次になる。

2つの独立したゲートを通過させることで、両方の観点が十分に検証されることを構造的に保証する。

## ロール分離の設計原則：能力ではなく構造の問題

5ロールの分離において最も重要な点は、これが**効率的な分業のためではなく、相互牽制による品質保証のための構造設計**だということだ。

AIの能力が向上し、1つのAIがすべてのロールを完璧にこなせるようになったとしても、ロールの統合は行わない。

なぜか。3つの理由がある。

### 異質性の担保

同一のAIが実装と監査を兼ねると、自身の出力に対する批判的検証が構造的に弱くなる。これは能力の問題ではなく、構造の問題だ。どんなに優秀な人間でも、自分のコードのバグは見つけにくい。それと同じだ。

ロールを分離することで、異なる視点・異なる評価基準による検証を保証する。

### 相互牽制の実効性

牽制は独立性があって初めて機能する。実装者が自身を監査する構造では、利益相反により牽制が形骸化する。

これは企業の内部統制と同じ原理だ。経理部門が自部門の監査を行っても意味がない。独立した監査部門が存在して初めて、牽制が機能する。

### 盲点の非重複

異なるロールは異なる盲点を持つ。コーディングエージェントが見落としがちな問題と、コードレビュアーが見落としがちな問題と、システム監査官が見落としがちな問題は、それぞれ異なる。

分離することで、単一視点では検出できない問題を構造的に捕捉できる。

## ロール間の牽制関係

5つのロールは独立して動作するが、相互に牽制し合う関係にある。

```
コーディングエージェント → コードレビュアー（品質ゲート）
                        → システム監査官（安全ゲート）

PM・スクラムマスター → コーディングエージェント（要件との整合性確認）

ユーザー・運用サポート → PM・スクラムマスター（エンドユーザー視点の検証）

システム監査官 → 全ロール（セキュリティ・リソースコストの指摘は最優先）
```

特に注目すべきは、システム監査官の指摘が全ロールに対して最優先で適用される点だ。セキュリティの脆弱性やリソースコストの問題は、他のどんな要件よりも優先される。

この牽制構造が機能するためには、各ロールが独立した文脈で動作することが前提だ。ロールの統合・兼務はこの前提を破壊するため、能力的に可能であっても行わない。

## 次章に向けて

5つのAIロールが定義できたところで、次章からは9つの開発フェーズの具体的な進め方に入る。まずはPhase 0〜2 ── 顧客の真の課題に到達するまで妥協しないプロセスから始める。
